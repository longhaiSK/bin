#!/usr/bin/env bash

# --- Jupytext Python to Notebook Converter (Uncomment Preprocessing Only) ---
#
# Converts a Python script (.py), previously generated by Jupytext (e.g., using
# the nb2py_script_with_markers script), back to a Jupyter Notebook (.ipynb).
# Assumes the input .py file already contains correct Jupytext cell markers.
# Includes a preprocessing step to uncomment lines within cells marked with 'tags=["remove"]'.
# The 'remove' tag itself is preserved for the final notebook conversion.
#
# Usage:
#   ./convert_to_notebook.sh <input_python_script.py> [output_notebook.ipynb]
#
# Arguments:
#   input_python_script.py : Path to the input Jupytext-formatted Python script.
#                            Assumes it might contain commented-out 'remove' blocks.
#   output_notebook.ipynb  : (Optional) Path for the output Jupyter Notebook.
#                            If not provided, defaults to the input filename
#                            with the extension changed to .ipynb.
# -------------------------------------------------

# --- Configuration ---
# Exit immediately if a command exits with a non-zero status.
set -e

# --- Argument Handling ---

# Check if at least one argument (input file) is provided
if [ "$#" -lt 1 ]; then
  echo "Error: Input Python script path is required."
  echo "Usage: $0 <input.py> [output.ipynb]"
  exit 1
fi

# Assign arguments to variables
input_file="$1"
output_file_arg="$2" # Store potential output argument

# --- Input File Validation ---

# Check if the input file exists
if [ ! -f "$input_file" ]; then
  echo "Error: Input file '$input_file' not found."
  exit 1
fi

# Optional: Warn if input file doesn't end with .py
if [[ "$input_file" != *.py ]]; then
  echo "Warning: Input file '$input_file' does not seem to be a Python script (.py extension missing)."
fi

# --- Determine Output Filename ---

output_file="" # Initialize output_file variable

if [ -z "$output_file_arg" ]; then
  # Output filename was NOT provided, derive it from the input filename
  if [[ "$input_file" == *.py ]]; then
    output_file="${input_file%.py}.ipynb"
  else
    output_file="${input_file}.ipynb"
    echo "Warning: Input file did not end with .py. Appending .ipynb for output filename."
  fi
  echo "Output filename not provided. Defaulting to: '$output_file'"
else
  # Output filename WAS provided
  output_file="$output_file_arg"
  if [[ "$output_file" != *.ipynb ]]; then
    echo "Warning: Specified output file '$output_file' does not end with .ipynb. Using it anyway."
  fi
fi

# --- Preprocessing Step: Uncomment "remove" blocks ---

# Create a temporary file - ensure it has .py suffix
# Use --suffix if available (GNU mktemp), otherwise use template (macOS/BSD mktemp)
if mktemp --suffix=.py --dry-run >/dev/null 2>&1; then
    temp_file_processed=$(mktemp --suffix=.py)
else
    temp_file_processed=$(mktemp /tmp/jupytext_prep_XXXXXX.py)
fi
# Ensure temporary file is removed on script exit
trap 'rm -f "$temp_file_processed"' EXIT

echo "Preprocessing '$input_file' to uncomment 'remove' blocks..."

# Use perl to process the input script
# - Sets $in_remove_block=1 when a line with 'tags=["remove"]' is found
# - Sets $in_remove_block=0 when any other '%%' marker is found
# - If $in_remove_block=1, attempts to remove leading '# ' before printing
# - Prints all lines (including the markers themselves)
perl -ne '
  BEGIN { $in_remove_block = 0; }
  if (/^# %% tags=\[.*"remove".*\]/) { # Check if line contains the remove tag marker
      print;                          # Print the marker line itself (preserves tag)
      $in_remove_block = 1;           # Set the flag
      next;                           # Skip to next line
  }
  if (/^# %%/) {                      # Check for any other cell marker
      print;                          # Print the marker line itself
      $in_remove_block = 0;           # Unset the flag
      next;                           # Skip to next line
  }
  # For all other lines (content lines)
  if ($in_remove_block) {
      s/^# //; # Attempt to remove leading "# " - only modifies $_ if match found
  }
  print; # Print the line (modified or original)
' "$input_file" > "$temp_file_processed" # Write processed output to the temp file


# Check perl exit status
if [ $? -ne 0 ]; then
  echo "Error: Uncommenting preprocessing step failed."
  # temp file removed by trap
  exit 1
fi

echo "Uncommenting preprocessing complete. Intermediate file: '$temp_file_processed'"
echo "You can inspect '$temp_file_processed' to check the substitutions."

# --- Execute Conversion ---

echo "Attempting to convert preprocessed file '$temp_file_processed' to '$output_file' using jupytext..."

# Run the jupytext command using the PREPROCESSED temporary file as input
# Use --from py:percent to be explicit about the expected input format
# Quote variables to handle spaces
jupytext --from py:percent --to notebook "$temp_file_processed" -o "$output_file"

# Check the exit status of the jupytext command
jupytext_exit_status=$? # Store exit status

if [ $jupytext_exit_status -eq 0 ]; then
  echo "Conversion successful! Output saved to '$output_file'"
  echo "Tags (including 'remove') should be retained in the notebook metadata."
else
  # Jupytext command likely printed its own error message
  echo "Error: Jupytext conversion failed."
  # temp file removed by trap
  exit 1 # Exit with a non-zero status to indicate failure
fi

# --- Script End ---
# temp file is removed by the trap upon exiting
exit 0

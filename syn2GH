#!/bin/zsh

# Turn nounset on only after we set sane defaults
set -e -o pipefail

# PATH bootstrap (robust)
for d in /opt/homebrew/bin /usr/local/bin; do
  [[ -d $d ]] && PATH="$d:$PATH"
done
if command -v brew >/dev/null 2>&1; then
  BREW_PREFIX="$(brew --prefix 2>/dev/null || true)"
  if [[ -n "$BREW_PREFIX" && -d "$BREW_PREFIX/bin" ]]; then
    PATH="$BREW_PREFIX/bin:$PATH"
  fi
fi
export PATH

# Provide defaults for variables
: "${REPO_DIR:=/Users/lol553/Github}"
: "${REMOTE:=origin}"
: "${BRANCH:=main}"
: "${GIT_SSH_COMMAND:=ssh}"

# Now enable nounset
set -u

# ---- Customize these search roots ----
declare -a ROOTS=("${githubroot:-$HOME/Github}")

# Exclude heavy/noisy directories
EXCLUDE_REGEX='(/\.venv/|/node_modules/|/\.cargo/)'
# -------------------------------------

# ---- Colors ----
C_BLUE=$'\033[0;34m'
C_GREEN=$'\033[32m'
C_YELLOW=$'\033[0;33m'
C_RED=$'\033[0;31m'
C_NONE=$'\033[0m'
C_GRAY=$'\033[0;90m'

# ---- Commit message ----
if [ -n "${1:-}" ]; then
  COMMIT_MSG="$1"
else
  COMMIT_MSG="syn2GH commit from $(hostname)"
fi

# ---- Run header ----
START_TS="$(TZ='America/Regina' date '+%Y-%m-%d %H:%M:%S %Z')"
echo -e "${C_BLUE}syn2GH start:${C_NONE} ${C_YELLOW}${START_TS}${C_NONE} on ${C_GREEN}$(hostname)${C_NONE}"

errors=()

process_repo() {
  local repo_dir="$1"
  
  # Go into directory silently first
  cd "$repo_dir" || return

  # Ensure it's a git repo
  if ! git rev-parse --git-dir >/dev/null 2>&1; then return; fi

  # Current branch (skip detached HEAD)
  BRANCH_NAME=$(git symbolic-ref --quiet --short HEAD 2>/dev/null)
  if [ -z "$BRANCH_NAME" ]; then return; fi

  # Ensure 'origin' remote exists
  if ! git remote get-url origin >/dev/null 2>&1; then return; fi

  # Always print Repo Name first
  echo
  echo -e "${C_BLUE}Repo: ${C_YELLOW}${repo_dir}${C_NONE}"

  # Upstream tracking (silently attempt to set if missing)
  TRACKING_REF=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
  if [ -z "$TRACKING_REF" ]; then
    DEFAULT_REMOTE_BRANCH=$(git remote show origin 2>/dev/null | awk '/HEAD branch/ {print $NF}')
    if [ -n "$DEFAULT_REMOTE_BRANCH" ]; then
      if git branch --set-upstream-to="origin/${DEFAULT_REMOTE_BRANCH}" "$BRANCH_NAME" >/dev/null 2>&1; then
        TRACKING_REF="origin/${DEFAULT_REMOTE_BRANCH}"
      fi
    fi
  fi

  # Fetch quietly to update remote tracking refs
  git fetch origin "$BRANCH_NAME" --quiet >/dev/null 2>&1 || true

  # ---------------------------------------------------------
  # 1. REMOTE CHECK
  # ---------------------------------------------------------
  local behind=0
  local ahead=0
  
  if [ -n "$TRACKING_REF" ]; then
    local counts
    counts=$(git rev-list --left-right --count HEAD...@{u} 2>/dev/null || echo "0 0")
    ahead=$(echo "$counts" | awk '{print $1}')
    behind=$(echo "$counts" | awk '{print $2}')
  fi

  if [ "$behind" -gt 0 ]; then
    # We are behind, pull changes
    OLD_HEAD=$(git rev-parse HEAD 2>/dev/null)
    
    if ! git pull --rebase --autostash origin "$BRANCH_NAME" >/dev/null 2>&1; then
      echo -e "${C_RED}  ! Pull failed. Resolve conflicts manually.${C_NONE}"
      errors+=("$repo_dir: pull failed")
      return
    fi
    
    NEW_HEAD=$(git rev-parse HEAD 2>/dev/null)
    echo -e "${C_BLUE}  Remote:${C_GREEN} ↓ Changes pulled:${C_NONE}"
    git log --pretty=format:"      %C(yellow)%h%C(reset) - %s %C(cyan)(%an, %ar)%C(reset)" "$OLD_HEAD".."$NEW_HEAD"
    echo ""
    git diff --stat "$OLD_HEAD".."$NEW_HEAD" | sed "s/.*/      &/"
  else
    echo -e "${C_BLUE}  Remote:${C_GRAY} No changes on remote.${C_NONE}"
  fi

  # ---------------------------------------------------------
  # 2. LOCAL CHECK
  # ---------------------------------------------------------
  
  # Check for uncommitted changes (dirty)
  local is_dirty=0
  if [ -n "$(git status --porcelain)" ]; then
    is_dirty=1
  fi

  # We need to recalculate 'ahead' if we just pulled, 
  # but strictly speaking, if we pulled successfully, ahead is still relative to what we had or just merged.
  # Let's re-check ahead count against the updated ref to be sure.
  if [ -n "$TRACKING_REF" ]; then
    ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
  fi

  if [ "$is_dirty" -eq 0 ] && [ "$ahead" -eq 0 ]; then
    echo -e "${C_BLUE}  Local: ${C_GRAY} No changes on local.${C_NONE}"
    return
  fi

  # If we are here, we have local changes (dirty or unpushed commits)
  echo -e "${C_BLUE}  Local: ${C_YELLOW} Changes detected. Processing...${C_NONE}"

  # Stage & Commit if dirty
  if [ "$is_dirty" -eq 1 ]; then
    git add -A
    if ! git diff --staged --quiet; then
      COMMIT_OUTPUT=$(git commit -m "$COMMIT_MSG" 2>&1)
      if [ $? -ne 0 ]; then
        echo -e "${C_RED}  ! Commit FAILED.${C_NONE}"
        echo -e "$COMMIT_OUTPUT"
        errors+=("$repo_dir: commit failed")
        return
      fi
    fi
  fi

  # Push
  # Capture what we are about to push for the log display
  if [ -n "$TRACKING_REF" ]; then
    TO_PUSH=$(git log --pretty=format:"      %C(yellow)%h%C(reset) - %s %C(cyan)(%ar)%C(reset)" "${TRACKING_REF}"..HEAD 2>/dev/null)
  else
    TO_PUSH=$(git log --pretty=format:"      %C(yellow)%h%C(reset) - %s %C(cyan)(%ar)%C(reset)" "origin/$BRANCH_NAME"..HEAD 2>/dev/null)
  fi

  PUSH_OUTPUT=$(git push origin "$BRANCH_NAME" 2>&1)
  
  if [ $? -eq 0 ]; then
    echo -e "${C_BLUE}  Push:  ${C_GREEN} ↑ Pushed successfully:${C_NONE}"
    if [ -n "$TO_PUSH" ]; then
      echo -e "$TO_PUSH"
    else
      # Fallback if variable was empty but push happened (rare)
      echo -e "      (New empty commit or branch setup)"
    fi
  else
    echo -e "${C_RED}  ! Push FAILED.${C_NONE}"
    echo -e "$PUSH_OUTPUT"
    errors+=("$repo_dir: push failed")
  fi
}

# ---- Build repo list ----
all_git_dirs=()
for root in "${ROOTS[@]}"; do
  [ -d "$root" ] || continue
  tmp_file="$(mktemp)"
  find "$root" -type d -name .git -prune -print 2>/dev/null | sed 's/\/\.git$//' | grep -vE "${EXCLUDE_REGEX}" | sort > "$tmp_file"
  last_line=""
  while IFS= read -r line; do
    if [ "$line" != "$last_line" ]; then
      all_git_dirs+=( "$line" )
      last_line="$line"
    fi
  done < "$tmp_file"
  rm -f "$tmp_file"
done

if [ ${#all_git_dirs[@]} -eq 0 ]; then
  echo -e "${C_YELLOW}No git repositories found under configured ROOTS.${C_NONE}"
  exit 0
fi

# ---- Process each repo ----
for repo in "${all_git_dirs[@]}"; do
  process_repo "$repo"
done

# ---- Summary of Errors ----
if [ ${#errors[@]} -ne 0 ]; then
  echo
  echo -e "${C_RED}Errors encountered:${C_NONE}"
  for err in "${errors[@]}"; do
    echo -e "  - $err"
  done
  exit 1
fi
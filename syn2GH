#!/bin/sh
""":"
exec "$(dirname "$0")/.venv/bin/python" "$0" "$@"
"""


import sys
import subprocess
import importlib

def require(package_name):
    """
    Python equivalent of R's require(): 
    Checks if a package exists; if not, installs it using pip.
    """
    try:
        importlib.import_module(package_name)
    except ImportError:
        print(f"ðŸ“¦ Package '{package_name}' not found. Installing...")
        try:
            # sys.executable ensures we install into the CURRENT python/venv
            subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
            print(f"âœ… {package_name} installed successfully.")
        except subprocess.CalledProcessError:
            print(f"âŒ Failed to install {package_name}.")
            sys.exit(1)

# --- 1. Standard Libraries (No install needed) ---
import os
import re
from datetime import datetime
from pathlib import Path

# --- 2. External Libraries (Auto-install if missing) ---
# Add any 3rd party packages you need here
require("numpy")
require("pandas")
require("matplotlib")

# --- 3. Import them now that they exist ---
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# --- FIX: Disable Output Buffering ---
sys.stdout.reconfigure(line_buffering=True)

# --- FIX: Set PATH for launchd (Crucial for finding git/ssh in background) ---
os.environ['PATH'] = "/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin" + os.pathsep + os.environ.get('PATH', '')

# --- Configuration ---
REPO_ROOTS = [Path(os.environ.get('githubroot', os.path.expanduser('~/Github')))]
REMOTE = os.environ.get('REMOTE', 'origin')
GIT_SSH_COMMAND = os.environ.get('GIT_SSH_COMMAND', 'ssh')

# --- Define core branches that require full pull/sync ---
CORE_BRANCHES = ['main', 'master', 'develop']

# Exclude heavy/noisy directories
EXCLUDE_REGEX = re.compile(r'(/node_modules/|/\.venv/|/\.cargo/)')

# --- Colors (ANSI Escape Codes) ---
COLORS = {
    'BLUE': '\033[0;34m',
    'GREEN': '\033[32m',
    'YELLOW': '\033[0;33m',
    'RED': '\033[0;31m',
    'CYAN': '\033[0;36m',
    'NONE': '\033[0m'
}

def colored_string(text, color_key):
    """Returns text wrapped in the specified color codes."""
    return f"{COLORS.get(color_key, COLORS['NONE'])}{text}{COLORS['NONE']}"

def run_git_command(command, cwd, check=True, capture_output=False, silent=False):
    """Wrapper for running Git commands."""
    try:
        if not silent and not capture_output:
            return subprocess.run(
                command,
                cwd=cwd,
                check=check,
                text=True,
                env=dict(os.environ, GIT_SSH_COMMAND=GIT_SSH_COMMAND)
            )
        else:
            result = subprocess.run(
                command,
                cwd=cwd,
                check=check,
                capture_output=True,
                text=True,
                env=dict(os.environ, GIT_SSH_COMMAND=GIT_SSH_COMMAND)
            )
            output_lines = []
            if result.stdout:
                output_lines.append(result.stdout.strip())
            if result.stderr:
                output_lines.append(result.stderr.strip())
            return '\n'.join(line for line in output_lines if line)

    except subprocess.CalledProcessError as e:
        if check:
            stderr_output = e.stderr.strip() if e.stderr else 'No error message.'
            raise RuntimeError(f"Command failed: {' '.join(command)}\nStderr: {stderr_output}")
        output_lines = []
        if e.stdout:
            output_lines.append(e.stdout.strip())
        if e.stderr:
            output_lines.append(e.stderr.strip())
        return '\n'.join(line for line in output_lines if line)

def find_git_repos(root_dirs, exclude_regex):
    """Recursively finds all Git directories under the given roots."""
    repo_dirs = set()
    for root in root_dirs:
        if not root.is_dir():
            continue
        for git_dir in root.rglob('.git'):
            repo_path = git_dir.parent.resolve()
            if exclude_regex.search(str(repo_path)):
                continue
            if (repo_path / '.git').is_dir():
                repo_dirs.add(repo_path)
    
    return sorted(list(repo_dirs), key=lambda p: str(p).lower())

def get_tracking_ref(repo_dir, branch_name):
    """Determines the current upstream tracking branch."""
    try:
        tracking_ref = run_git_command(
            ['git', 'rev-parse', '--abbrev-ref', '--symbolic-full-name', '@{u}'],
            cwd=repo_dir,
            check=False,
            capture_output=True,
            silent=True
        )
        if 'fatal:' in tracking_ref or 'unknown revision' in tracking_ref or not tracking_ref:
             return None
        return tracking_ref
    except RuntimeError:
        return None

def process_repo(repo_dir, commit_msg, errors):
    repo_str = str(repo_dir)

    # 1. Validation Checks & Get Current Branch Name
    try:
        if not run_git_command(['git', 'rev-parse', '--is-inside-work-tree'], cwd=repo_dir, check=False, capture_output=True, silent=True):
             return
        branch_name = run_git_command(['git', 'symbolic-ref', '--quiet', '--short', 'HEAD'], cwd=repo_dir, capture_output=True, silent=True)
        if not branch_name:
            return 
        run_git_command(['git', 'remote', 'get-url', REMOTE], cwd=repo_dir, check=True, capture_output=True, silent=True)
        
    except (subprocess.CalledProcessError, RuntimeError):
        return 

    is_core_branch = branch_name in CORE_BRANCHES
    tracking_ref = get_tracking_ref(repo_dir, branch_name)

    # 3. Check Status (Fast check to exit early)
    has_local_changes = False
    is_ahead = False
    is_behind = False

    try:
        if run_git_command(['git', 'status', '--porcelain'], cwd=repo_dir, capture_output=True, silent=True):
            has_local_changes = True
        
        # Silent Fetch
        try:
            subprocess.run(
                ['git', 'fetch', REMOTE, branch_name, '--quiet'], 
                cwd=repo_dir, 
                check=False,
                stdout=subprocess.DEVNULL, 
                stderr=subprocess.DEVNULL
            )
        except Exception:
             pass 

        if tracking_ref:
            counts_str = run_git_command(
                ['git', 'rev-list', '--left-right', '--count', f'HEAD...{tracking_ref}'],
                cwd=repo_dir,
                check=False,
                capture_output=True,
                silent=True
            ) or "0 0"
            try:
                ahead, behind = map(int, counts_str.split())
                if ahead > 0: is_ahead = True
                if behind > 0: is_behind = True
            except ValueError:
                is_ahead = True 

    except RuntimeError:
        pass 

    # Logic to proceed
    needs_action = False
    if has_local_changes:
        needs_action = True
    elif not tracking_ref and run_git_command(['git', 'log', f'{REMOTE}/{branch_name}..HEAD'], cwd=repo_dir, check=False, capture_output=True, silent=True):
        needs_action = True
    elif is_core_branch and (is_ahead or is_behind):
        needs_action = True
    elif not is_core_branch and is_ahead:
        needs_action = True
    else:
        return 

    # --- ACTION (Buffered Output) ---
    
    # We buffer logs and only print them if a meaningful action occurs
    log_buffer = []
    action_taken = False
    
    fetch_output = ""
    if is_core_branch:
        try:
            fetch_output = run_git_command(['git', 'fetch', REMOTE, branch_name], cwd=repo_dir, check=False, capture_output=True, silent=True)
            fetch_output = '\n'.join([line for line in fetch_output.splitlines() if line.strip() and not line.strip().startswith('From ')])
        except Exception:
             fetch_output = ""
    
    if fetch_output:
        log_buffer.append(fetch_output)

    try:
        old_head = run_git_command(['git', 'rev-parse', 'HEAD'], cwd=repo_dir, capture_output=True, silent=True)
    except RuntimeError:
        old_head = "INITIAL_COMMIT" 

    # 1) Pull
    if is_core_branch and tracking_ref: 
        try:
            pull_out = run_git_command(['git', 'pull', '--rebase', '--autostash', REMOTE, branch_name], cwd=repo_dir, check=True, capture_output=True)
            # We assume output from pull usually indicates activity, but we verify with head change
        except RuntimeError:
            print(colored_string(f"\n{'-'*55}", 'CYAN'))
            print(colored_string(f"Repo: {repo_str} ({branch_name})", 'BLUE'))
            print(colored_string(f"\n  ! Pull failed. Resolve conflicts manually.", 'RED'))
            errors.append(f"{repo_str}: pull failed on branch {branch_name}")
            return # Exit immediately on error, printing header
    else:
        # Feature pull is skipped, so no log needed unless debugging
        pass

    try:
        new_head = run_git_command(['git', 'rev-parse', 'HEAD'], cwd=repo_dir, capture_output=True, silent=True)
    except RuntimeError:
        new_head = None

    # Check if Pull did something
    if old_head != new_head and old_head != "INITIAL_COMMIT":
        action_taken = True
        log_buffer.append(colored_string(f"1) Pull (CORE): {COLORS['GREEN']}â†“ Changes pulled:", 'BLUE'))
        log_output = run_git_command(
            ['git', 'log', f'{old_head}..{new_head}', '--pretty=format:      %C(yellow)%h%C(reset) - %s %C(cyan)(%an, %ar)%C(reset)'],
            cwd=repo_dir,
            capture_output=True,
            silent=True
        )
        log_buffer.append(log_output)
        
    # 2) Stage
    run_git_command(['git', 'add', '-A'], cwd=repo_dir, check=True, silent=True)
    
    # 3) Commit
    has_staged_changes = False
    try:
        subprocess.run(['git', 'diff', '--staged', '--quiet'], cwd=repo_dir, check=True, capture_output=True)
        has_staged_changes = False
    except subprocess.CalledProcessError:
        has_staged_changes = True

    if has_staged_changes:
        try:
            run_git_command(['git', 'commit', '-m', commit_msg], cwd=repo_dir, check=True, silent=True)
            action_taken = True # Commit is a meaningful action
            
            log_buffer.append(colored_string(f"3) Commit: {COLORS['GREEN']}âœ“ Committed:", 'BLUE'))
            commit_stat = run_git_command(
                ['git', 'show', '--stat', '--oneline', '--no-color', 'HEAD'],
                cwd=repo_dir,
                capture_output=True,
                silent=True
            )
            stat_lines = commit_stat.splitlines()
            if len(stat_lines) > 1:
                formatted_stat = '\n'.join(f"      {COLORS['RED']}{line}{COLORS['NONE']}" for line in stat_lines[1:])
                log_buffer.append(formatted_stat)
        except RuntimeError:
            print(colored_string(f"\n{'-'*55}", 'CYAN'))
            print(colored_string(f"Repo: {repo_str} ({branch_name})", 'BLUE'))
            print(colored_string(f"3) Commit: {COLORS['RED']}! Failed.", 'BLUE'))
            errors.append(f"{repo_str}: commit failed on branch {branch_name}")
            return

    # 4) Push
    should_push = False
    push_options = [REMOTE, branch_name]
    
    if not tracking_ref:
        should_push = True
        push_options = ['--set-upstream', REMOTE, branch_name]
    else:
        ref_to_check = tracking_ref
        try:
            commits_to_push = run_git_command(
                ['git', 'log', '--pretty=format:%h', f'{ref_to_check}..HEAD'], 
                cwd=repo_dir, check=False, capture_output=True, silent=True
            )
            if commits_to_push:
                should_push = True
        except RuntimeError:
            should_push = True 

    if should_push:
        try:
            push_command = ['git', 'push'] + push_options
            run_git_command(push_command, cwd=repo_dir, check=True, silent=True)
            action_taken = True # Push is a meaningful action
            log_buffer.append(colored_string(f"4) Push: {COLORS['GREEN']}âœ“ Pushed successfully.", 'BLUE'))
        except RuntimeError as e:
            print(colored_string(f"\n{'-'*55}", 'CYAN'))
            print(colored_string(f"Repo: {repo_str} ({branch_name})", 'BLUE'))
            print(colored_string(f"4) Push: {COLORS['RED']}â†‘ Push FAILED.", 'BLUE'))
            # --- FIX: Print the actual reason ---
            print(colored_string(f"    Reason: {e}", 'YELLOW'))
            errors.append(f"{repo_str}: push failed on branch {branch_name}")
            return

    # --- FINAL OUTPUT DECISION ---
    # Only print if something actually happened (action_taken)
    if action_taken:
        print(colored_string(f"\n{'-'*55}", 'CYAN'))
        print(colored_string(f"Repo: {repo_str} ({branch_name})", 'BLUE'))
        for log_line in log_buffer:
            print(log_line)

def main():
    if len(sys.argv) > 1:
        commit_msg = sys.argv[1]
    else:
        try:
            hostname = subprocess.check_output(['hostname'], text=True).strip()
        except Exception:
            hostname = 'unknown_host'
        commit_msg = f"syn2GH from {hostname}"

    start_ts = datetime.now().astimezone().strftime('%Y-%m-%d %H:%M:%S %Z')
    print(colored_string(f"syn2GH start: {start_ts} on {os.uname().nodename}", 'RED'))
    
    try:
        git_dirs = find_git_repos(REPO_ROOTS, EXCLUDE_REGEX)
    except Exception as e:
        print(colored_string(f"Error finding repositories: {e}", 'RED'))
        sys.exit(1)
        
    if not git_dirs:
        print(colored_string("No git repositories found.", 'YELLOW'))
        sys.exit(0)

    errors = []
    for repo in git_dirs:
        process_repo(repo, commit_msg, errors)
        
    end_ts = datetime.now().astimezone().strftime('%Y-%m-%d %H:%M:%S %Z')
    print(colored_string(f"\n{'-'*55}", 'CYAN'))
    print(colored_string(f"syn2GH end: {end_ts} on {os.uname().nodename}", 'RED'))

    if errors:
        print(colored_string(f"\n--- Errors ({len(errors)}) ---", 'RED'))
        for error in errors:
            print(colored_string(f"  - {error}", 'RED'))
        sys.exit(1)
    else:
        print(colored_string("\n--- Synchronization complete with no errors. ---", 'GREEN'))
        sys.exit(0)

if __name__ == "__main__":
    main()